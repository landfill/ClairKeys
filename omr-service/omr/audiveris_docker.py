"""
Audiveris Docker-based OMR Processor
Uses weidi/audiveris-docker container for PDF to MusicXML conversion
"""

import asyncio
import subprocess
import logging
from pathlib import Path
from typing import Optional
import os
import tempfile
import shutil

logger = logging.getLogger(__name__)

class AudiverisDockerProcessor:
    """Processes PDF files using toprock/audiveris Docker container"""
    
    def __init__(self):
        self.docker_image = "toprock/audiveris"
        self.container_name = "audiveris-processor"
        
    async def process_pdf(self, pdf_path: Path, output_dir: Path) -> Path:
        """
        Process PDF file using Audiveris Docker container
        
        Args:
            pdf_path: Path to input PDF file
            output_dir: Directory for output files
            
        Returns:
            Path to generated MusicXML file
        """
        try:
            logger.info(f"Starting Audiveris Docker processing for {pdf_path}")
            
            # Create temporary directories for Docker volume mounts
            input_temp_dir = Path("/data") / "audiveris_input"
            output_temp_dir = Path("/data") / "audiveris_output"
            
            input_temp_dir.mkdir(exist_ok=True)
            output_temp_dir.mkdir(exist_ok=True)
            
            # Copy PDF to input directory
            input_pdf_path = input_temp_dir / "input.pdf"
            shutil.copy2(pdf_path, input_pdf_path)
            
            # Run Audiveris Docker container
            cmd = [
                "docker", "run", "--rm",
                "-v", f"{input_temp_dir}:/input",
                "-v", f"{output_temp_dir}:/output",
                self.docker_image
            ]
            
            logger.info(f"Running Audiveris Docker command: {' '.join(cmd)}")
            
            # Run the container
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd="/tmp"
            )
            
            stdout, stderr = await process.communicate()
            
            # Check if process completed successfully
            if process.returncode != 0:
                error_msg = f"Audiveris Docker failed with return code {process.returncode}"
                if stderr:
                    error_msg += f"\nStderr: {stderr.decode()}"
                if stdout:
                    error_msg += f"\nStdout: {stdout.decode()}"
                logger.error(error_msg)
                raise RuntimeError(error_msg)
            
            # Find the generated MusicXML file
            output_files = list(output_temp_dir.glob("*.mxl")) + list(output_temp_dir.glob("*.xml"))
            
            if not output_files:
                raise FileNotFoundError("No MusicXML output file generated by Audiveris Docker")
            
            # Copy the result to our output directory
            musicxml_path = output_dir / "output.xml"
            
            # If it's an .mxl file, we might need to extract it
            source_file = output_files[0]
            if source_file.suffix.lower() == '.mxl':
                # .mxl is compressed MusicXML, extract it
                await self._extract_mxl(source_file, musicxml_path)
            else:
                # Copy XML directly
                shutil.copy2(source_file, musicxml_path)
            
            # Cleanup temporary directories
            shutil.rmtree(input_temp_dir, ignore_errors=True)
            shutil.rmtree(output_temp_dir, ignore_errors=True)
            
            logger.info(f"Successfully generated MusicXML: {musicxml_path}")
            return musicxml_path
            
        except Exception as e:
            logger.error(f"Error in Audiveris Docker processing: {str(e)}")
            
            # Cleanup on error
            for temp_dir in [input_temp_dir, output_temp_dir]:
                if 'temp_dir' in locals() and temp_dir.exists():
                    shutil.rmtree(temp_dir, ignore_errors=True)
            
            raise
    
    async def _extract_mxl(self, mxl_path: Path, output_path: Path):
        """Extract MusicXML from compressed .mxl file"""
        try:
            import zipfile
            
            with zipfile.ZipFile(mxl_path, 'r') as zip_file:
                # Find the main MusicXML file (usually has .xml extension)
                xml_files = [name for name in zip_file.namelist() if name.endswith('.xml')]
                
                if not xml_files:
                    raise ValueError("No XML file found in MXL archive")
                
                # Use the first XML file found
                xml_filename = xml_files[0]
                
                # Extract to output path
                with zip_file.open(xml_filename) as source_file:
                    with open(output_path, 'wb') as dest_file:
                        dest_file.write(source_file.read())
                
                logger.info(f"Extracted {xml_filename} from MXL to {output_path}")
                
        except Exception as e:
            logger.error(f"Error extracting MXL file: {str(e)}")
            # Fallback: just copy the file as is
            shutil.copy2(mxl_path, output_path)
    
    async def validate_audiveris_installation(self) -> bool:
        """
        Validate that Docker and Audiveris image are available
        
        Returns:
            True if Docker and Audiveris are available, False otherwise
        """
        try:
            # Check if Docker is available
            process = await asyncio.create_subprocess_exec(
                "docker", "--version",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                logger.error("Docker not available")
                return False
            
            # Check if Audiveris image is available (try to pull if not present)
            process = await asyncio.create_subprocess_exec(
                "docker", "pull", self.docker_image,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                logger.error(f"Failed to pull Audiveris Docker image: {self.docker_image}")
                return False
            
            logger.info("Audiveris Docker installation validated successfully")
            return True
            
        except Exception as e:
            logger.error(f"Error validating Audiveris Docker installation: {str(e)}")
            return False